// Copyright 2022 Citra Emulator Project
// Licensed under GPLv2 or any later version
// Refer to the license.txt file included.

#pragma once

#include <string_view>

namespace HostShaders {

constexpr std::string_view REFINE_FRAG = {
"// Copyright 2022 Citra Emulator Project\n"
"// Licensed under GPLv2 or any later version\n"
"// Refer to the license.txt file included.\n"
"\n"
"//? #version 430 core\n"
"precision mediump float;\n"
"\n"
"layout(location = 0) in vec2 tex_coord;\n"
"layout(location = 0) out vec4 frag_color;\n"
"\n"
"layout(binding = 0) uniform sampler2D HOOKED;\n"
"layout(binding = 1) uniform sampler2D LUMAD;\n"
"\n"
"const float LINE_DETECT_THRESHOLD = 0.4;\n"
"const float STRENGTH = 0.6;\n"
"\n"
"// the original shader used the alpha channel for luminance,\n"
"// which doesn't work for our use case\n"
"struct RGBAL {\n"
"    vec4 c;\n"
"    float l;\n"
"};\n"
"\n"
"vec4 getAverage(vec4 cc, vec4 a, vec4 b, vec4 c) {\n"
"    return cc * (1.0 - STRENGTH) + ((a + b + c) / 3.0) * STRENGTH;\n"
"}\n"
"\n"
"#define GetRGBAL(x_offset, y_offset)                                                                   RGBAL(textureLodOffset(HOOKED, tex_coord, 0.0, ivec2(x_offset, y_offset)),                               textureLodOffset(LUMAD, tex_coord, 0.0, ivec2(x_offset, y_offset)).x)\n"
"\n"
"float min3v(float a, float b, float c) {\n"
"    return min(min(a, b), c);\n"
"}\n"
"\n"
"float max3v(float a, float b, float c) {\n"
"    return max(max(a, b), c);\n"
"}\n"
"\n"
"vec4 Compute() {\n"
"    RGBAL cc = GetRGBAL(0, 0);\n"
"\n"
"    if (cc.l > LINE_DETECT_THRESHOLD) {\n"
"        return cc.c;\n"
"    }\n"
"\n"
"    RGBAL tl = GetRGBAL(-1, -1);\n"
"    RGBAL t = GetRGBAL(0, -1);\n"
"    RGBAL tr = GetRGBAL(1, -1);\n"
"\n"
"    RGBAL l = GetRGBAL(-1, 0);\n"
"\n"
"    RGBAL r = GetRGBAL(1, 0);\n"
"\n"
"    RGBAL bl = GetRGBAL(-1, 1);\n"
"    RGBAL b = GetRGBAL(0, 1);\n"
"    RGBAL br = GetRGBAL(1, 1);\n"
"\n"
"    // Kernel 0 and 4\n"
"    float maxDark = max3v(br.l, b.l, bl.l);\n"
"    float minLight = min3v(tl.l, t.l, tr.l);\n"
"\n"
"    if (minLight > cc.l && minLight > maxDark) {\n"
"        return getAverage(cc.c, tl.c, t.c, tr.c);\n"
"    } else {\n"
"        maxDark = max3v(tl.l, t.l, tr.l);\n"
"        minLight = min3v(br.l, b.l, bl.l);\n"
"        if (minLight > cc.l && minLight > maxDark) {\n"
"            return getAverage(cc.c, br.c, b.c, bl.c);\n"
"        }\n"
"    }\n"
"\n"
"    // Kernel 1 and 5\n"
"    maxDark = max3v(cc.l, l.l, b.l);\n"
"    minLight = min3v(r.l, t.l, tr.l);\n"
"\n"
"    if (minLight > maxDark) {\n"
"        return getAverage(cc.c, r.c, t.c, tr.c);\n"
"    } else {\n"
"        maxDark = max3v(cc.l, r.l, t.l);\n"
"        minLight = min3v(bl.l, l.l, b.l);\n"
"        if (minLight > maxDark) {\n"
"            return getAverage(cc.c, bl.c, l.c, b.c);\n"
"        }\n"
"    }\n"
"\n"
"    // Kernel 2 and 6\n"
"    maxDark = max3v(l.l, tl.l, bl.l);\n"
"    minLight = min3v(r.l, br.l, tr.l);\n"
"\n"
"    if (minLight > cc.l && minLight > maxDark) {\n"
"        return getAverage(cc.c, r.c, br.c, tr.c);\n"
"    } else {\n"
"        maxDark = max3v(r.l, br.l, tr.l);\n"
"        minLight = min3v(l.l, tl.l, bl.l);\n"
"        if (minLight > cc.l && minLight > maxDark) {\n"
"            return getAverage(cc.c, l.c, tl.c, bl.c);\n"
"        }\n"
"    }\n"
"\n"
"    // Kernel 3 and 7\n"
"    maxDark = max3v(cc.l, l.l, t.l);\n"
"    minLight = min3v(r.l, br.l, b.l);\n"
"\n"
"    if (minLight > maxDark) {\n"
"        return getAverage(cc.c, r.c, br.c, b.c);\n"
"    } else {\n"
"        maxDark = max3v(cc.l, r.l, b.l);\n"
"        minLight = min3v(t.l, l.l, tl.l);\n"
"        if (minLight > maxDark) {\n"
"            return getAverage(cc.c, t.c, l.c, tl.c);\n"
"        }\n"
"    }\n"
"\n"
"    return cc.c;\n"
"}\n"
"\n"
"void main() {\n"
"    frag_color = Compute();\n"
"}\n"
"\n"

};

} // namespace HostShaders
